<!doctype html>
<html lang="en-us">
<head>
<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Unity WebGL Player | ShiftAtMidnight</title>

<style>
html, body {
	margin: 0;
	padding: 0;
	height: 100%;
	width: 100%;
	overflow: hidden;
	background: black;
}

#unity-container, #unity-canvas {
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
}

#loading-text {
	position: absolute;
	top: 40%;
	width: 100%;
	text-align: center;
	color: white;
	font-family: Inter, sans-serif;
	font-size: 28px;
	z-index: 5;
}

#start-button {
	position: absolute;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	padding: 18px 45px;
	font-size: 22px;
	background: white;
	border: none;
	cursor: pointer;
	z-index: 10;
}

#start-button:hover {
	background: #ddd;
}
</style>
</head>

<body>

<div id="loading-text">Click to Start</div>
<button id="start-button">Start Game</button>

<div id="unity-container">
	<canvas id="unity-canvas" tabindex="-1"></canvas>
</div>

<!-- ðŸ”¥ GLOBAL AUDIO PATCH -->
<script>
(function() {
	// Patch AudioParam.value to block NaN / Infinity
	const descriptor = Object.getOwnPropertyDescriptor(AudioParam.prototype, "value");
	if (descriptor && descriptor.set) {
		Object.defineProperty(AudioParam.prototype, "value", {
			set: function(v) {
				if (Number.isFinite(v)) {
					descriptor.set.call(this, v);
				} else {
					console.warn("Blocked non-finite AudioParam value:", v);
				}
			},
			get: descriptor.get
		});
	}

	// Patch channel.setPosition globally to replace invalid positions with 0
	const oldAppend = document.body.appendChild;
	document.body.appendChild = function(el) {
		if (el.tagName === "SCRIPT" && el.src.includes("loader.js")) {
			el.addEventListener("load", () => {
				if (window.channel?.prototype?.setPosition) {
					const proto = window.channel.prototype;
					const old = proto.setPosition;
					proto.setPosition = function(x, y, z) {
						if (!Number.isFinite(x)) x = 0;
						if (!Number.isFinite(y)) y = 0;
						if (!Number.isFinite(z)) z = 0;
						old.call(this, x, y, z);
					};
				}
			});
		}
		return oldAppend.call(this, el);
	};
})();
</script>

<script>
// File merging functions
function mergeFiles(fileParts) {
	return new Promise((resolve, reject) => {
		let buffers = [];

		function fetchPart(index) {
			if (index >= fileParts.length) {
				resolve(URL.createObjectURL(new Blob(buffers)));
				return;
			}

			fetch(fileParts[index])
				.then(response => response.arrayBuffer())
				.then(data => {
					buffers.push(data);
					document.getElementById("loading-text").textContent =
						`Downloading (${index + 1}/${fileParts.length})`;
					fetchPart(index + 1);
				})
				.catch(reject);
		}

		fetchPart(0);
	});
}

function getParts(file, start, end) {
	let parts = [];
	for (let i = start; i <= end; i++) {
		parts.push(file + ".part" + i);
	}
	return parts;
}

// Click-to-start
document.getElementById("start-button").addEventListener("click", function() {
	this.remove();
	document.getElementById("loading-text").textContent = "Loading...";

	Promise.all([
		mergeFiles(getParts("Build/ShiftAtMidnightPort.data", 1, 5)),
		mergeFiles(getParts("Build/ShiftAtMidnightPort.wasm", 1, 2))
	]).then(([dataUrl, wasmUrl]) => {

		const buildUrl = "Build";
		const config = {
			dataUrl: dataUrl,
			frameworkUrl: buildUrl + "/ShiftAtMidnightPort.framework.js",
			codeUrl: wasmUrl,
			streamingAssetsUrl: "StreamingAssets",
			companyName: "slqntdevss",
			productName: "ShiftAtMidnight",
			productVersion: "1.00"
		};

		const loaderScript = document.createElement("script");
		loaderScript.src = buildUrl + "/ShiftAtMidnightPort.loader.js";

		loaderScript.onload = () => {
			// Create Unity instance
			createUnityInstance(
				document.getElementById("unity-canvas"),
				config,
				(progress) => {
					document.getElementById("loading-text").textContent =
						"Loading... " + Math.round(progress * 100) + "%";
				}
			).then((unityInstance) => {
				document.getElementById("loading-text").remove();

				// ðŸ”§ SIMPLE VENDING MACHINE PATCH
				(function() {
					function patchAllVending(unityInstance) {
						if (!unityInstance || !unityInstance.Module) return;

						const originalClick = unityInstance.Module?.onVendingClick;
						unityInstance.Module.onVendingClick = function(machineID) {
							if (unityInstance.Module.playerInventory) {
								unityInstance.Module.playerInventory.hasBoughtDrink = true;
								console.log("Drink marked as bought!");
							}
							if (originalClick) originalClick(machineID);
						};
					}

					// Keep patching until Unity loads
					const interval = setInterval(() => {
						patchAllVending(unityInstance);
					}, 100);
				})();
			}).catch((message) => {
				alert(message);
			});
		};

		document.body.appendChild(loaderScript);
	});
});
</script>

</body>
</html>
